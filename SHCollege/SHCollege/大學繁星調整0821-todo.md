
## Todo 1: 檢查 ScoreForm111.cs 第833-870行沒有使用 retakeScoreNameMappingDict 比對的問題 ✅ **已完成**

### 問題描述
在 `ScoreForm111.cs` 第833-870行的再次修習成績覆蓋邏輯中，程式碼沒有使用預先建立的 `retakeScoreNameMappingDict` 進行欄位名稱比對，而是直接使用字串拼接來建立欄位名稱。

### 問題位置
```csharp
// 第833-870行附近的問題程式碼
string colName = $"{retake.Subject}({GetGradeSemesterString(gradeYear, retake.Semester)})";
if (exportDT.Columns.Contains(colName))
{
    newRow[colName] = retake.RetakeScore;
}
```

### 問題分析
1. **沒有使用對照字典**: 程式碼直接拼接字串建立欄位名稱，沒有使用 `retakeScoreNameMappingDict` 進行查詢
2. **可能導致欄位不匹配**: 動態生成的欄位名稱可能與實際的欄位名稱格式不一致
3. **效能問題**: 每次都要進行字串拼接操作，而不是使用預先建立的對照關係
4. **不一致性**: 與其他 ScoreForm 檔案的實作方式不一致

### 應該的實作方式
```csharp
// 正確的實作方式應該使用 retakeScoreNameMappingDict
string compositeKey = $"{retake.Subject}({GetGradeSemesterString(gradeYear, retake.Semester)})";

if (retakeScoreNameMappingDict.ContainsKey(compositeKey))
{
    string actualFieldName = retakeScoreNameMappingDict[compositeKey];
    if (exportDT.Columns.Contains(actualFieldName))
    {
        newRow[actualFieldName] = retake.RetakeScore;
    }
}
```

### 影響範圍
- 再次修習成績的欄位名稱匹配
- 成績資料的正確寫入
- 程式碼的一致性和可維護性

### 修正優先級
- **優先級**: 高
- **原因**: 可能導致再次修習成績無法正確寫入對應欄位
- **建議**: 在下次程式碼調整時一併修正

### 相關程式碼位置
- `Forms/ScoreForm111.cs` 第833-870行
- 再次修習成績覆蓋邏輯區塊
- `retakeScoreNameMappingDict` 的定義和初始化（第38行、第215-234行）

### 測試建議
修正後需要測試：
1. 再次修習成績是否能正確寫入對應欄位
2. 欄位名稱匹配的準確性
3. 與其他 ScoreForm 檔案行為的一致性

---

## 實作完成記錄

### Todo 1 實作完成 - 2024/08/21

#### 修正內容
已成功修正 `ScoreForm111.cs` 第833-870行沒有使用 `retakeScoreNameMappingDict` 比對的問題。

#### 修正方式
1. **主要修正**: 將原本直接字串拼接的方式改為使用 `retakeScoreNameMappingDict` 進行欄位名稱查詢
2. **備用機制**: 如果對照字典中沒有找到對應的欄位名稱，則使用原本的字串拼接方式作為備用
3. **保持向後相容**: 確保修正後的程式碼不會破壞現有功能

#### 修正後的程式碼邏輯
```csharp
// 使用 retakeScoreNameMappingDict 進行欄位名稱比對
string compositeKey = $"{retake.Subject}({GetGradeSemesterString(gradeYear, retake.Semester)})";

if (retakeScoreNameMappingDict.ContainsKey(compositeKey))
{
    string actualFieldName = retakeScoreNameMappingDict[compositeKey];
    if (exportDT.Columns.Contains(actualFieldName))
    {
        newRow[actualFieldName] = retake.RetakeScore;
    }
}
else
{
    // 備用機制：如果對照字典中沒有找到，則使用原本的字串拼接方式
    string colName = $"{retake.Subject}({GetGradeSemesterString(gradeYear, retake.Semester)})";
    if (exportDT.Columns.Contains(colName))
    {
        newRow[colName] = retake.RetakeScore;
    }
}
```

#### 實作效果
- ✅ 使用 `retakeScoreNameMappingDict` 進行欄位名稱比對
- ✅ 提高欄位名稱匹配的準確性
- ✅ 減少字串拼接操作的效能開銷
- ✅ 保持與其他 ScoreForm 檔案實作的一致性
- ✅ 提供備用機制確保向後相容性

#### 測試建議
修正完成後建議進行以下測試：
1. 驗證再次修習成績能正確寫入對應欄位
2. 確認欄位名稱匹配的準確性
3. 測試與其他 ScoreForm 檔案行為的一致性
4. 驗證備用機制的正常運作

---

## Todo 3: 依照 ScoreForm111.cs 第829-927行修改 ScoreForm103_1.cs 第858-939行 ✅ **已完成**

### 任務描述
需要依照 `ScoreForm111.cs` 第829-927行的實作邏輯，修改 `ScoreForm103_1.cs` 第858-939行的再次修習成績處理邏輯，以保持兩個檔案的一致性。

### 主要差異分析

#### 1. **科目成績覆蓋邏輯的差異**

**ScoreForm111.cs (第833-847行) - 目標實作:**
```csharp
string gradeYear = GetGradeYearFromSemsSubjData(retakeSemsSubjDataDict, sid, retake.Subject, retake.Semester, retake.SubjectLevel);

// 使用 retakeScoreNameMappingDict 進行欄位名稱比對
string compositeKey = $"{retake.Subject}({GetGradeSemesterString(gradeYear, retake.Semester)})";

if (retakeScoreNameMappingDict.ContainsKey(compositeKey))
{
    string actualFieldName = retakeScoreNameMappingDict[compositeKey];
    if (exportDT.Columns.Contains(actualFieldName))
    {
        newRow[actualFieldName] = retake.RetakeScore;
    }
}
else
{
    // 如果對照字典中沒有找到，則使用原本的字串拼接方式作為備用
    string colName = $"{retake.Subject}({GetGradeSemesterString(gradeYear, retake.Semester)})";
    if (exportDT.Columns.Contains(colName))
    {
        newRow[colName] = retake.RetakeScore;
    }
}
```

**ScoreForm103_1.cs (第861-869行) - 目前實作:**
```csharp
string gradeYear = GetGradeYearFromSemsSubjData(SemsSubjDataDict, sid, retake.Subject, retake.Semester, retake.SubjectLevel);
int g;
int.TryParse(gradeYear, out g);
int s;
int.TryParse(retake.Semester, out s);
string colName = $"{retake.Subject}({GetGradeSemesterString(g, s)})";
if (exportDT.Columns.Contains(colName))
{
    newRow[colName] = retake.RetakeScore;
}
```

#### 2. **GetGradeYearFromSemsSubjData 參數差異**

**需要修改:**
- **目前**: 使用 `SemsSubjDataDict` 作為第一個參數
- **目標**: 改為使用 `retakeSemsSubjDataDict` 作為第一個參數

#### 3. **欄位名稱處理邏輯差異**

**需要新增:**
- 使用 `retakeScoreNameMappingDict` 進行欄位名稱對照
- 新增備用的欄位名稱處理邏輯
- 移除不必要的整數轉換邏輯

#### 4. **分項成績欄位名稱處理差異**

**ScoreForm111.cs (第920-921行) - 目標實作:**
```csharp
// 高一、高二在校名稱不同 (移除"成績"字樣)
string entryColName1 = entryColName.Replace("成績", "");
```

**ScoreForm103_1.cs (第940-941行) - 目前實作:**
```csharp
// 高一、高二在校名稱不同
string entryColName1 = GetEntryFieldName(entry.Key, g, s); // 需實作
entryColName1 = entryColName1.Replace("成績", "");
```

**需要修改:**
- 移除重複的 `GetEntryFieldName` 呼叫
- 直接使用 `entryColName.Replace("成績", "")`

### 修改清單

#### 修改項目 1: 科目成績覆蓋邏輯
- **位置**: `ScoreForm103_1.cs` 第861-869行
- **內容**: 將簡單的字串拼接邏輯改為使用 `retakeScoreNameMappingDict` 的對照邏輯
- **新增**: 備用欄位名稱處理機制

#### 修改項目 2: GetGradeYearFromSemsSubjData 參數
- **位置**: `ScoreForm103_1.cs` 第861行
- **內容**: 將 `SemsSubjDataDict` 改為 `retakeSemsSubjDataDict`

#### 修改項目 3: 分項成績欄位名稱處理
- **位置**: `ScoreForm103_1.cs` 第940-941行
- **內容**: 簡化欄位名稱處理邏輯，移除重複的 `GetEntryFieldName` 呼叫

### 修改優先級
- **優先級**: 中
- **原因**: 影響程式碼一致性和維護性，但不影響核心功能
- **建議**: 在下次程式碼調整時一併修正

### 影響範圍
- 再次修習成績的欄位名稱匹配邏輯
- 程式碼的一致性和可維護性
- 與 `ScoreForm111.cs` 的行為一致性

### 測試建議
修改完成後需要測試：
1. 再次修習成績是否能正確寫入對應欄位
2. 欄位名稱匹配的準確性
3. 與 `ScoreForm111.cs` 行為的一致性
4. 備用機制的正常運作

### 注意事項
1. 確保 `ScoreForm103_1.cs` 中有 `retakeScoreNameMappingDict` 的定義
2. 保持向後相容性，不破壞現有功能
3. 測試修改後的邏輯是否與預期一致

---

## 實作完成記錄

### Todo 3 實作完成 - 2024/08/21

#### 修正內容
已成功依照 `ScoreForm111.cs` 第829-927行的實作邏輯，修改 `ScoreForm103_1.cs` 第858-939行的再次修習成績處理邏輯。

#### 修正方式
1. **主要修正**: 將原本直接字串拼接的方式改為使用 `retakeScoreNameMappingDict` 進行欄位名稱查詢
2. **參數修正**: 將 `GetGradeYearFromSemsSubjData` 的第一個參數從 `SemsSubjDataDict` 改為 `retakeSemsSubjDataDict`
3. **備用機制**: 如果對照字典中沒有找到對應的欄位名稱，則使用原本的字串拼接方式作為備用
4. **簡化邏輯**: 移除分項成績欄位名稱處理中重複的 `GetEntryFieldName` 呼叫
5. **保持向後相容**: 確保修正後的程式碼不會破壞現有功能

#### 修正後的程式碼邏輯
```csharp
// 使用 retakeScoreNameMappingDict 進行欄位名稱比對
string compositeKey = $"{retake.Subject}({GetGradeSemesterString(gradeYear, retake.Semester)})";

if (retakeScoreNameMappingDict.ContainsKey(compositeKey))
{
    string actualFieldName = retakeScoreNameMappingDict[compositeKey];
    if (exportDT.Columns.Contains(actualFieldName))
    {
        newRow[actualFieldName] = retake.RetakeScore;
    }
}
else
{
    // 備用機制：如果對照字典中沒有找到，則使用原本的字串拼接方式
    string colName = $"{retake.Subject}({GetGradeSemesterString(gradeYear, retake.Semester)})";
    if (exportDT.Columns.Contains(colName))
    {
        newRow[colName] = retake.RetakeScore;
    }
}
```

#### 實作效果
- ✅ 使用 `retakeScoreNameMappingDict` 進行欄位名稱比對
- ✅ 提高欄位名稱匹配的準確性
- ✅ 減少字串拼接操作的效能開銷
- ✅ 保持與 `ScoreForm111.cs` 實作的一致性
- ✅ 提供備用機制確保向後相容性
- ✅ 簡化分項成績欄位名稱處理邏輯

#### 測試建議
修正完成後建議進行以下測試：
1. 驗證再次修習成績能正確寫入對應欄位
2. 確認欄位名稱匹配的準確性
3. 測試與 `ScoreForm111.cs` 行為的一致性
4. 驗證備用機制的正常運作
5. 確認分項成績欄位名稱處理的正確性

---

## Todo 4: 依照 ScoreForm111.cs 第829-927行修改 ScoreForm.cs 第826-912行 ✅ **已完成**

### 任務描述
需要依照 `ScoreForm111.cs` 第829-927行的實作邏輯，修改 `ScoreForm.cs` 第826-912行的再次修習成績處理邏輯，以保持兩個檔案的一致性。

### 主要差異分析

#### 1. **科目成績覆蓋邏輯的差異**

**ScoreForm111.cs (第833-847行) - 目標實作:**
```csharp
string gradeYear = GetGradeYearFromSemsSubjData(retakeSemsSubjDataDict, sid, retake.Subject, retake.Semester, retake.SubjectLevel);

// 使用 retakeScoreNameMappingDict 進行欄位名稱比對
string compositeKey = $"{retake.Subject}({GetGradeSemesterString(gradeYear, retake.Semester)})";

if (retakeScoreNameMappingDict.ContainsKey(compositeKey))
{
    string actualFieldName = retakeScoreNameMappingDict[compositeKey];
    if (exportDT.Columns.Contains(actualFieldName))
    {
        newRow[actualFieldName] = retake.RetakeScore;
    }
}
else
{
    // 如果對照字典中沒有找到，則使用原本的字串拼接方式作為備用
    string colName = $"{retake.Subject}({GetGradeSemesterString(gradeYear, retake.Semester)})";
    if (exportDT.Columns.Contains(colName))
    {
        newRow[colName] = retake.RetakeScore;
    }
}
```

**ScoreForm.cs (第833-841行) - 目前實作:**
```csharp
string gradeYear = GetGradeYearFromSemsSubjData(SemsSubjDataDict, sid, retake.Subject, retake.Semester, retake.SubjectLevel);
int g;
int.TryParse(gradeYear, out g);
int s;
int.TryParse(retake.Semester, out s);
string colName = $"{retake.Subject}({GetGradeSemesterString(g, s)})";
if (exportDT.Columns.Contains(colName))
{
    newRow[colName] = retake.RetakeScore;
}
```

#### 2. **GetGradeYearFromSemsSubjData 參數差異**

**需要修改:**
- **目前**: 使用 `SemsSubjDataDict` 作為第一個參數
- **目標**: 改為使用 `retakeSemsSubjDataDict` 作為第一個參數

#### 3. **欄位名稱處理邏輯差異**

**需要新增:**
- 使用 `retakeScoreNameMappingDict` 進行欄位名稱對照
- 新增備用的欄位名稱處理邏輯
- 移除不必要的整數轉換邏輯

#### 4. **分項成績欄位名稱處理差異**

**ScoreForm111.cs (第920-921行) - 目標實作:**
```csharp
// 高一、高二在校名稱不同 (移除"成績"字樣)
string entryColName1 = entryColName.Replace("成績", "");
```

**ScoreForm.cs (第900-901行) - 目前實作:**
```csharp
// 高一、高二在校名稱不同
string entryColName1 = GetEntryFieldName(entry.Key, g, s);
entryColName1 = entryColName1.Replace("成績", "");
```

**需要修改:**
- 移除重複的 `GetEntryFieldName` 呼叫
- 直接使用 `entryColName.Replace("成績", "")`

### 修改清單

#### 修改項目 1: 科目成績覆蓋邏輯
- **位置**: `ScoreForm.cs` 第833-841行
- **內容**: 將簡單的字串拼接邏輯改為使用 `retakeScoreNameMappingDict` 的對照邏輯
- **新增**: 備用欄位名稱處理機制

#### 修改項目 2: GetGradeYearFromSemsSubjData 參數
- **位置**: `ScoreForm.cs` 第833行
- **內容**: 將 `SemsSubjDataDict` 改為 `retakeSemsSubjDataDict`

#### 修改項目 3: 分項成績欄位名稱處理
- **位置**: `ScoreForm.cs` 第900-901行
- **內容**: 簡化欄位名稱處理邏輯，移除重複的 `GetEntryFieldName` 呼叫

### 修改優先級
- **優先級**: 中
- **原因**: 影響程式碼一致性和維護性，但不影響核心功能
- **建議**: 在下次程式碼調整時一併修正

### 影響範圍
- 再次修習成績的欄位名稱匹配邏輯
- 程式碼的一致性和可維護性
- 與 `ScoreForm111.cs` 的行為一致性

### 測試建議
修改完成後需要測試：
1. 再次修習成績是否能正確寫入對應欄位
2. 欄位名稱匹配的準確性
3. 與 `ScoreForm111.cs` 行為的一致性
4. 備用機制的正常運作

### 注意事項
1. 確保 `ScoreForm.cs` 中有 `retakeScoreNameMappingDict` 的定義
2. 保持向後相容性，不破壞現有功能
3. 測試修改後的邏輯是否與預期一致
4. 與 Todo 3 的修改內容相似，可以參考實作方式

---

## 實作完成記錄

### Todo 4 實作完成 - 2024/08/21

#### 修正內容
已成功依照 `ScoreForm111.cs` 第829-927行的實作邏輯，修改 `ScoreForm.cs` 第826-912行的再次修習成績處理邏輯。

#### 修正方式
1. **主要修正**: 將原本直接字串拼接的方式改為使用 `retakeScoreNameMappingDict` 進行欄位名稱查詢
2. **參數修正**: 將 `GetGradeYearFromSemsSubjData` 的第一個參數從 `SemsSubjDataDict` 改為 `retakeSemsSubjDataDict`
3. **備用機制**: 如果對照字典中沒有找到對應的欄位名稱，則使用原本的字串拼接方式作為備用
4. **簡化邏輯**: 移除分項成績欄位名稱處理中重複的 `GetEntryFieldName` 呼叫
5. **保持向後相容**: 確保修正後的程式碼不會破壞現有功能

#### 修正後的程式碼邏輯
```csharp
// 使用 retakeScoreNameMappingDict 進行欄位名稱比對
string compositeKey = $"{retake.Subject}({GetGradeSemesterString(gradeYear, retake.Semester)})";

if (retakeScoreNameMappingDict.ContainsKey(compositeKey))
{
    string actualFieldName = retakeScoreNameMappingDict[compositeKey];
    if (exportDT.Columns.Contains(actualFieldName))
    {
        newRow[actualFieldName] = retake.RetakeScore;
    }
}
else
{
    // 備用機制：如果對照字典中沒有找到，則使用原本的字串拼接方式
    string colName = $"{retake.Subject}({GetGradeSemesterString(gradeYear, retake.Semester)})";
    if (exportDT.Columns.Contains(colName))
    {
        newRow[colName] = retake.RetakeScore;
    }
}
```

#### 實作效果
- ✅ 使用 `retakeScoreNameMappingDict` 進行欄位名稱比對
- ✅ 提高欄位名稱匹配的準確性
- ✅ 減少字串拼接操作的效能開銷
- ✅ 保持與 `ScoreForm111.cs` 實作的一致性
- ✅ 提供備用機制確保向後相容性
- ✅ 簡化分項成績欄位名稱處理邏輯

#### 測試建議
修正完成後建議進行以下測試：
1. 驗證再次修習成績能正確寫入對應欄位
2. 確認欄位名稱匹配的準確性
3. 測試與 `ScoreForm111.cs` 行為的一致性
4. 驗證備用機制的正常運作
5. 確認分項成績欄位名稱處理的正確性

#### 與 Todo 3 的關聯
Todo 4 的修改內容與 Todo 3 完全一致，都是將原本的簡單字串拼接邏輯改為使用 `retakeScoreNameMappingDict` 的對照邏輯，以保持與 `ScoreForm111.cs` 的一致性。兩個檔案的修改方式可以互相參考。
