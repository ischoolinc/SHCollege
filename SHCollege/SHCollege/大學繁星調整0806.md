# [2024-xx-xx] RetakeScoreHelper.GetRetakeScores 方法修改記錄

## 修改內容
**調整 SQL 查詢邏輯，當同一位學生有相同科目名稱與科目級別時，只取得最新一筆（學年度學期最新的）**

### 修改前
```sql
SELECT
    student_id,
    school_year,
    semester,
    subject,
    subj_level,
    detail->>'name' AS name,
    detail->>'value' AS value
FROM student_score
WHERE detail->>'name' = '再次修習成績'
ORDER BY student_id, school_year, semester, subject;
```

### 修改後
```sql
WITH student_score AS (
    SELECT
        ref_student_id AS student_id,
        school_year,
        semester,
        subject,
        subj_level,
        jsonb_array_elements(detail) AS detail
    FROM
        student_learning_history
    WHERE
        serial_no = '5.3'
        AND name = '重讀成績'
        AND ref_student_id IN ({idList})
),
ranked_scores AS (
    SELECT
        student_id,
        school_year,
        semester,
        subject,
        subj_level,
        detail->>'name' AS name,
        detail->>'value' AS value,
        ROW_NUMBER() OVER (
            PARTITION BY student_id, subject, subj_level 
            ORDER BY school_year DESC, semester DESC
        ) AS rn
    FROM student_score
    WHERE detail->>'name' = '再次修習成績'
)
SELECT
    student_id,
    school_year,
    semester,
    subject,
    subj_level,
    name,
    value
FROM ranked_scores
WHERE rn = 1
ORDER BY student_id, school_year, semester, subject;
```

### 主要變更
1. **新增 CTE (Common Table Expression)**：`ranked_scores` 用於排序和分組
2. **使用 ROW_NUMBER() 函數**：
   - `PARTITION BY student_id, subject, subj_level`：按學生ID、科目名稱、科目級別分組
   - `ORDER BY school_year DESC, semester DESC`：按學年度降序、學期降序排序
   - `WHERE rn = 1`：只取每組的第一筆（最新的）
3. **避免重複資料**：確保每個學生每個科目每個級別只會有一筆最新的再次修習成績記錄

### 範例說明
**修改前**：同一位學生可能有多筆相同科目的再次修習成績
```
學生A, 108學年度, 1學期, 國文, 基礎, 85分
學生A, 108學年度, 2學期, 國文, 基礎, 90分
學生A, 109學年度, 1學期, 國文, 基礎, 88分
```

**修改後**：只取得最新的一筆
```
學生A, 109學年度, 1學期, 國文, 基礎, 88分
```

---

# [2024-xx-xx] ScoreForm103_1.cs 修正記錄

## 修正內容
1. **retakeDict 作用域錯誤修正**：
   - 將 `retakeScores`、`retakeDict`、`retakeStudentIDs` 的宣告與初始化，移動到所有變數宣告之後、`foreach (DataRow dr in StudBaseList)` 之前，確保在 foreach 內外都能正確存取，解決 `The name 'retakeDict' does not exist in the current context` 錯誤。
2. **GetGradeSemesterString 型別修正**：
   - 修正呼叫 `GetGradeSemesterString` 時，將 `gradeYear` 及 `retake.Semester` 皆以 `int` 型別傳入，避免 `Argument 1/2: cannot convert from 'string' to 'int'` 錯誤。
   - 例如：
     ```csharp
     int g, s;
     int.TryParse(gradeYear, out g);
     int.TryParse(retake.Semester, out s);
     string colName = $"{retake.Subject}({GetGradeSemesterString(g, s)})";
     ```

---

# ScoreForm111.cs 第206至782行程式運作解析

## 1. 資料輸出主流程
- 針對每一位學生（DataRow dr in StudBaseList）進行資料處理與成績填入。
- 先將成績暫存字典 `ssScoreDict` 清空。
- 依據學生ID（sid）建立新資料列 `newRow`，並將所有欄位預設為-1。
- 依序填入學號、身分證號碼、姓名、就讀科學程班別（如有資料則填入，否則預設-1）。
- 報名學測或術科考試情形預設為1。
- 若有對應的 SHSAT 學生資料，則填入班級座號與學測報名序號。

## 2. 比對學期科目成績（#region 比對學期科目成績）
- 若該學生有學期科目成績資料（SemsSubjDataDict），針對每一筆成績：
  - 依據年級與學期（如一上、一下、二上、二下、三上、三下）比對欄位名稱。
  - 透過 `_ScoreNameMappingDict` 將科目名稱對應到正確的欄位，若有多筆則用 _ 連接。
  - 透過 `_CalScoreNameMappingDict` 即時計算分項平均，將原始成績與學分數累加到 `ssScoreDict`。

## 3. 比對學期分項成績（#region 比對學期分項成績）
- 若該學生有分項成績資料（SemsEntryDataDict），針對每一筆分項成績：
  - 依據設定的 `_chkSScore` 決定比對「學業(原始)」或「學業」分項。
  - 依據年級、學期、分項名稱，將分項成績填入對應的欄位（如學業成績總平均(高一上)等）。
  - 欄位名稱由 `_SaveFieldConfigList` 決定。

## 4. 科目成績平均覆蓋
- 針對 `ssScoreDict` 中已計算的欄位，若 exportDT 有該欄位，則將平均值填入 newRow。

## 5. 新資料列加入輸出表
- 將 newRow 加入 exportDT.Rows。

## 6. newRow 欄位說明
- newRow 的欄位來自 exportDT.Columns，主要由 _SaveFieldConfigList 產生，預設情況下則來自 GetDefaultFieldName() 方法。
- 預設欄位如下：
  - 班級座號
  - 學測報名序號
  - 身分證號碼
  - 學業成績總平均(高一上)
  - 國語文(高一上)
  - 英語文(高一上)
  - 數學(高一上)
  - 物理(高一上)
  - 化學(高一上)
  - 生物(高一上)
  - 地球科學(高一上)
  - 歷史(高一上)
  - 地理(高一上)
  - 公民與社會(高一上)
  - 音樂(高一上)
  - 美術(高一上)
  - 舞蹈(高一上)
  - 體育(高一上)
  - 生活科技(高一上)
  - 資訊科技(高一上)
  - 學業成績總平均(高一下)
  - 國語文(高一下)
  - 英語文(高一下)
  - 數學(高一下)
  - 物理(高一下)
  - 化學(高一下)
  - 生物(高一下)
  - 地球科學(高一下)
  - 歷史(高一下)
  - 地理(高一下)
  - 公民與社會(高一下)
  - 音樂(高一下)
  - 美術(高一下)
  - 舞蹈(高一下)
  - 體育(高一下)
  - 生活科技(高一下)
  - 資訊科技(高一下)
  - 學業成績總平均(高二上)
  - 國語文(高二上)
  - 英語文(高二上)
  - 數學(高二上)
  - 物理(高二上)
  - 化學(高二上)
  - 生物(高二上)
  - 地球科學(高二上)
  - 歷史(高二上)
  - 地理(高二上)
  - 公民與社會(高二上)
  - 音樂(高二上)
  - 美術(高二上)
  - 舞蹈(高二上)
  - 體育(高二上)
  - 生活科技(高二上)
  - 資訊科技(高二上)
  - 學業成績總平均(高二下)
  - 國語文(高二下)
  - 英語文(高二下)
  - 數學(高二下)
  - 物理(高二下)
  - 化學(高二下)
  - 生物(高二下)
  - 地球科學(高二下)
  - 歷史(高二下)
  - 地理(高二下)
  - 公民與社會(高二下)
  - 音樂(高二下)
  - 美術(高二下)
  - 舞蹈(高二下)
  - 體育(高二下)
  - 生活科技(高二下)
  - 資訊科技(高二下)
  - 學業成績總平均(高三上)
  - 國語文(高三上)
  - 英語文(高三上)
  - 生活科技(高三上)
  - 資訊科技(高三上)
  - 就讀科、學程、班別
  - 報名學測或術科考試情形
  - 姓名
- 若有自訂欄位設定，則會依 _SaveFieldConfigList 內容動態調整。

---

### 主要運作重點
- 依據學生基本資料與成績資料，動態產生每位學生的成績輸出列。
- 科目成績與分項成績分開比對與填入，並支援多學制（如四技、五專等年級對應）。
- 支援欄位動態對應與平均計算，確保資料正確性與彈性。

---

如需更細節的欄位對應、計算方式，請參考 `_ScoreNameMappingDict`、`_CalScoreNameMappingDict`、`_SaveFieldConfigList` 及 `ParseSubjScore`、`ParseEntryScore` 等相關方法與設定。

## 7. SemsSubjDataDict 的 List<DataRow> 欄位內容
- 每一筆 DataRow 代表一門科目的學期成績，包含以下欄位：
  - sid：學生ID
  - 成績年級：該筆成績所屬年級
  - 學期：第幾學期
  - 學年度：學年度
  - 分項類別：如學業、體育等
  - 科目：科目名稱
  - 科目級別：科目級別（如I、II等）
  - 學分數：該科目學分數
  - 取得學分：是否取得學分
  - 必選修：必修或選修
  - 校部訂：部訂或校訂
  - 補修成績：補修後成績
  - 原始成績：原始成績分數
  - 補考成績：補考後成績
  - 再次修習成績：重修後成績
  - 重修學年度：重修時的學年度
  - 重修學期：重修時的學期
  - 學年調整成績：學年調整後成績
  - 手動調整成績：擇優採計或手動調整成績
  - 不計學分：是否不計學分
  - 不需評分：是否不需評分

- 這些欄位可用於成績比對、計算、欄位填入等各種用途。

## 8. SemsEntryDataDict 的 List<DataRow> 欄位內容
- 每一筆 DataRow 代表一個分項的學期成績，包含以下欄位：
  - sid：學生ID
  - 成績年級：該筆成績所屬年級
  - 學期：第幾學期
  - 學年度：學年度
  - 分項：分項名稱（如學業、體育等）
  - 成績：該分項的成績分數

- 這些欄位可用於分項成績比對、欄位填入、平均計算等用途。

## 9. ssScoreDict 加總平均覆蓋欄位說明（ScoreForm111.cs 770-777 行）
- 這段程式碼會將 ssScoreDict 字典中已計算的平均分數，填入 newRow 的對應欄位。
- 流程如下：
  - 針對 ssScoreDict 的每個 key（欄位名稱），檢查 exportDT 是否有該欄位。
  - 若有，則將該欄位的值設為 ssScoreDict[key].GetAverage()，即加總後的平均分數。
- 主要用途：
  - 處理需要加總平均的科目或分項（如「自然」為多科目平均），將計算結果正確填入輸出資料。
  - 確保輸出成績資料的正確性與完整性。

## 10. newRow 輸出結果說明
- newRow 代表每位學生的最終輸出資料列。
- 程式會針對每一位學生建立一個 newRow，填入該生所有成績與資訊。
- 每位學生在輸出結果（exportDT）中只會有一筆 newRow 資料。
- 若有 100 位學生，最後輸出就有 100 筆資料，每筆對應一位學生。
- 每筆 newRow 皆包含該生所有欄位的成績與相關資訊。

## Todo 1: 新增再次修習成績覆蓋邏輯設計討論
- （本段需實作於 ScoreForm111.cs 檔案，主要修改 _bgExporData_DoWork 方法）
- 目標：於成績處理流程中，針對每位學生，查詢其是否有重修（再次修習）成績，並用再次修習成績覆蓋原本同年級+學期+科目名稱的成績。
- 方法：
  1. 於 `_bgExporData_DoWork` 取得 StudentIDList 後，呼叫 `GetRetakeScores(StudentIDList)`，取得所有學生的再次修習成績（List<RetakeScoreInfo>）。
  2. 將結果依 StudentID 分組成 Dictionary，方便查詢。
  3. 在處理每位學生 newRow 時，若該生有再次修習成績，則：
     - 依據 RetakeScoreInfo 的年級、學期、科目名稱，組合出 newRow 對應的欄位名稱（如「國語文(高二下)」）。
     - 若 exportDT.Columns 包含該欄位，則將 newRow[colName] 設為再次修習成績（RetakeScore）。
- 注意事項：
  - 欄位命名規則需與現有欄位一致（如「國語文(高二下)」）。
  - 若同一欄位有多筆再次修習成績，需決定以哪一筆為主（如最新或最高分）。
  - 覆蓋範圍需確認，是僅針對原始成績，還是所有成績類型。
- 範例偽碼：
```csharp
List<RetakeScoreInfo> retakeScores = RetakeScoreHelper.GetRetakeScores(StudentIDList);
var retakeDict = retakeScores.GroupBy(r => r.StudentID)
                             .ToDictionary(g => g.Key, g => g.ToList());
var retakeStudentIDs = new HashSet<string>(retakeScores.Select(r => r.StudentID));
foreach (DataRow dr in StudBaseList)
{
    string sid = dr["sid"].ToString();
    // ...原本填值流程...
    if (retakeDict.ContainsKey(sid))
    {
        foreach (var retake in retakeDict[sid])
        {
            string colName = $"{retake.Subject}({GetGradeSemesterString(retake.SchoolYear, retake.Semester)})";
            if (exportDT.Columns.Contains(colName))
            {
                newRow[colName] = retake.RetakeScore;
            }
        }
    }
    // ...newRow 加入 exportDT.Rows...
}
```
- 需實作 GetGradeSemesterString 方法，將學年、學期轉換為正確的欄位名稱格式。
- 請先確認以上設計與需求細節，再進行程式碼實作。

- 程式碼插入時機：
  - 再次修習成績覆蓋的程式碼，應放在
    ```csharp
    // 當+ 科目成績附蓋
    foreach (string key in ssScoreDict.Keys)
    {
        if (exportDT.Columns.Contains(key))
        {
            newRow[key] = ssScoreDict[key].GetAverage();
        }
    }
    ```
    之後，且在 `exportDT.Rows.Add(newRow);` 之前。
  - 這樣可確保 newRow 的所有成績都已經填好、加總平均也覆蓋完畢後，再用再次修習成績取代同年級+學期+科目名稱的欄位值，確保再次修習成績為最終結果。

## Todo 2: 針對有再次修習成績的學生重新計算學期成績
- 目標：取得所有有再次修習成績（retakeScores）的學生ID，並針對這些學生重新計算其學期成績。
- 步驟：
  1. 取得 retakeScores 後，將所有 RetakeScoreInfo.StudentID 收集成一個 HashSet 或 List，得到有再次修習成績的學生ID清單。
     ```csharp
     var retakeStudentIDs = new HashSet<string>(retakeScores.Select(r => r.StudentID));
     ```
  2. 在處理每位學生 newRow 時，判斷該學生ID是否在 retakeStudentIDs 中。
  3. 若是，則針對該生的學期成績（如學業成績總平均等）進行重新計算，計算時需將再次修習成績納入。
- 設計重點：
  - 重新計算時，需確保原有成績資料已被再次修習成績正確覆蓋。
  - 學期成績的計算方式需與現有邏輯一致，僅資料來源需更新為已覆蓋後的成績。
  - 可考慮將重新計算邏輯封裝為獨立方法，便於維護與測試。
- 注意：
  - 僅針對有再次修習成績的學生進行重新計算，其他學生維持原有計算流程。

## Todo 3: 針對有再次修習成績的學生即時計算學期成績
- 目標：針對有再次修習成績的學生，整理出需要重新計算的學期成績，並即時計算新的學期成績。
- 步驟：
  1. 依 Todo 2 已取得的 retakeStudentIDs，針對每位學生進行處理。
  2. 針對每位學生，使用 SemsSubjDataDict 取得該生所有科目成績（List<DataRow>）。
  3. 針對 retakeScores，依年級+學期+科目名稱，比對並覆蓋 SemsSubjDataDict 中對應的成績資料。
  4. 整理出每個需要重新計算的 (studentID, gradeYear, semester) 組合。
  5. 針對每個組合，呼叫 CalcSemesterEntryScore 方法，傳入：
     - subjScoreRows（已覆蓋後的 List<DataRow>）
     - studentID
     - gradeYear
     - semester
     - getScoreCalcRule（計算規則方法）
     即時計算新的學期成績。
- 設計重點：
  - 覆蓋 SemsSubjDataDict 時，需以 retakeScores 的年級、學期、科目為 key，比對並更新對應 DataRow 的成績欄位。
  - CalcSemesterEntryScore 計算結果可直接更新到 newRow 或暫存結構，供後續輸出使用。
  - 建議將比對與覆蓋、即時計算邏輯封裝為獨立方法，提升可讀性與維護性。
- 注意：
  - 僅針對有再次修習成績的學生與學期進行即時計算，其他學生維持原有計算流程。

## Todo 4: 覆蓋原本學期分項成績（參考比對學期分項成績作法）
- 目標：將重新計算學期成績的學生，依據新計算結果，覆蓋原本的學期分項成績。
- 步驟：
  1. 針對已即時計算出新學期成績的學生與學期（見 Todo 3），取得對應的分項欄位名稱（如「學業成績總平均(高二下)」等）。
  2. 參考現有「比對學期分項成績」的作法，將新計算結果填入 newRow 的對應欄位。
     - 例如：`newRow[分項欄位名稱] = 新計算成績`。
  3. 覆蓋時機應在所有成績資料已覆蓋、即時計算完成後，且在 newRow 加入 exportDT.Rows 之前。
- 設計重點：
  - 分項欄位名稱需與現有欄位命名規則一致。
  - 覆蓋邏輯可參考現有「比對學期分項成績」區塊的欄位填入方式，確保一致性。
  - 建議將覆蓋邏輯封裝為獨立方法，便於維護與測試。
- 注意：
  - 僅針對有重新計算學期成績的學生進行分項成績覆蓋，其他學生維持原有流程。

---

### 補充：retakeDict 作用域修正
- 為確保再次修習成績（retakeScores）、學生ID集合（retakeStudentIDs）、以及分組字典（retakeDict）在整個資料處理流程中都可正確存取，這三個變數的宣告與初始化必須放在 foreach (DataRow dr in StudBaseList) 之前。
- 這樣可避免「retakeDict does not exist in the current context」等作用域錯誤。
- 範例：
  ```csharp
  List<RetakeScoreInfo> retakeScores = RetakeScoreHelper.GetRetakeScores(StudentIDList);
  var retakeDict = retakeScores.GroupBy(r => r.StudentID)
                              .ToDictionary(g => g.Key, g => g.ToList());
  var retakeStudentIDs = new HashSet<string>(retakeScores.Select(r => r.StudentID));
  foreach (DataRow dr in StudBaseList)
  {
      // ...
  }
  ```
- 請務必將這段宣告放在 foreach 之前，確保後續所有資料處理邏輯都能正確使用這些變數。

---

### 補充：recalcSet 應以年級（gradeYear）+學期為主
- 原本程式碼誤用 SchoolYear 作為重新計算學期成績的依據，這樣會導致分項成績計算錯誤。
- 已修正為：
  - 由 SemsSubjDataDict 依 studentID、科目、學期比對取得正確的 gradeYear（年級）。
  - recalcSet 組合為 (gradeYear, semester)，確保重新計算分項成績時依據正確的年級與學期。
- 新增工具方法：
  ```csharp
  private string GetGradeYearFromSemsSubjData(Dictionary<string, List<DataRow>> semsSubjDataDict, string sid, string subject, string semester)
  {
      if (semsSubjDataDict.ContainsKey(sid))
      {
          var rows = semsSubjDataDict[sid];
          var match = rows.FirstOrDefault(r => r["科目"].ToString().Trim() == subject && r["學期"].ToString() == semester);
          if (match != null)
              return match["成績年級"].ToString();
      }
      return "";
  }
  ```
- 這樣可確保所有學期成績的重新計算與覆蓋都以正確的年級為依據。

---

### 補充：GetGradeYearFromSemsSubjData 加入科目級別判斷
- 為確保取得年級（gradeYear）時更精確，GetGradeYearFromSemsSubjData 方法已加入科目級別（SubjectLevel）判斷。
- 現在會同時比對「科目」、「學期」以及「科目級別」三個欄位。
- 修正版方法範例：
  ```csharp
  private string GetGradeYearFromSemsSubjData(Dictionary<string, List<DataRow>> semsSubjDataDict, string sid, string subject, string semester, string subjectLevel = null)
  {
      if (semsSubjDataDict.ContainsKey(sid))
      {
          var rows = semsSubjDataDict[sid];
          var match = rows.FirstOrDefault(r =>
              r["科目"].ToString().Trim() == subject &&
              r["學期"].ToString() == semester &&
              (subjectLevel == null || r.Table.Columns.Contains("科目級別") && r["科目級別"].ToString() == subjectLevel)
          );
          if (match != null)
              return match["成績年級"].ToString();
      }
      return "";
  }
  ```
- 呼叫時請傳入 retake.SubjectLevel，確保比對正確。

---

### 補充：CalcSemesterEntryScore 分項名稱一致性處理
- 在 CalcSemesterEntryScore 方法中，若 entry == "學業"，則自動改為 "學業成績總平均"。
- 這樣可確保分項名稱與欄位命名規則一致，避免資料對應錯誤。
- 相關程式碼片段：
  ```csharp
  string entry = dr["分項類別"].ToString();
  if (entry == "學業")
      entry = "學業成績總平均";
  ```

---

### 補充：CalcSemesterEntryScore 僅計算指定年級與學期
- 在 CalcSemesterEntryScore 方法中，只有當 `dr["成績年級"] == gradeYear` 且 `dr["學期"] == semester` 時，該筆資料才會被納入計算。
- 這樣可確保只處理目標年級與學期的成績資料，其他資料一律不計算。
- 相關程式碼片段：
  ```csharp
  if (dr["成績年級"].ToString() == gradeYear.ToString() && dr["學期"].ToString() == semester.ToString())
  {
      // ...計算邏輯...
  }
  ```

---

### 補充：如何區分使用原始成績或原始及補考成績擇優
- 在 ScoreForm111.cs 中，是否使用「原始成績」還是「原始及補考成績擇優」，由 `_chkSScore` 這個布林變數控制。
- 控制來源：
  - `_chkSScore` 會根據 UI 下拉選單（`cboSubjectScoreType`）的選擇來設定。
  - 相關程式碼：
    ```csharp
    if (cboSubjectScoreType.Text == "原始成績")
        _chkSScore = true;
    else
        _chkSScore = false;
    ```
- 影響範圍：
  - 在計算科目成績時，會根據 `_chkSScore` 決定呼叫 `ParseSubjScore` 或 `ParseEntryScore` 的邏輯。
  - 例如：
    ```csharp
    private decimal ParseSubjScore(DataRow dr)
    {
        decimal d1, d2;
        if (_chkSScore)
        {
            decimal.TryParse(dr["原始成績"].ToString(), out d1);
            return d1;
        }
        else
        {
            decimal.TryParse(dr["原始成績"].ToString(), out d1);
            decimal.TryParse(dr["補考成績"].ToString(), out d2);
            if (d1 >= d2)
                return d1;
            else
                return d2;
        }
    }
    ```
- 使用時機：
  - 使用者在 UI 上選擇「原始成績」或「原始及補考成績擇優」後，點擊匯出，程式就會根據這個選擇來決定計算方式。
- 總結：
  - 你可以透過 UI 下拉選單來切換要用「原始成績」還是「原始及補考成績擇優」。
  - 內部是用 `_chkSScore` 這個變數來控制所有成績計算的邏輯分歧。

## Todo 5: CalcSemesterEntryScore 支援傳入 _chkSScore 以分辨成績計算方式
- 目標：讓 Utility.cs 的 CalcSemesterEntryScore 函數可以接收 _chkSScore 參數，據以分辨是只用「原始成績」還是「原始及補考成績擇優」。
- 設計重點：
  1. 在 CalcSemesterEntryScore 的參數列表中新增一個 bool 型別參數（如 useOriginalScoreOnly 或 chkSScore）。
  2. 在計算分項成績時，根據此參數決定採計「原始成績」或「原始及補考成績擇優」。
  3. 呼叫端（如 ScoreForm111.cs）需將 _chkSScore 傳入。
- 建議修改方式：
  - 函數簽名範例：
    ```csharp
    public static Dictionary<string, decimal> CalcSemesterEntryScore(
        List<DataRow> subjScoreRows,
        string studentID,
        int gradeYear,
        int semester,
        Func<string, System.Xml.XmlElement> getScoreCalcRule,
        bool chkSScore)
    ```
  - 在分項成績計算邏輯中，根據 chkSScore 決定採計欄位（如只用「原始成績」或「原始及補考成績擇優」）。
- 這樣可讓分項成績計算方式與 UI 選擇保持一致，提升彈性與正確性。

---

### 補充：subjScoreRows 包含原始成績與補考成績欄位
- 在 Utility.cs 的 SQL 查詢設計下，subjScoreRows（List<DataRow>）每一筆資料都同時包含：
  - `原始成績`
  - `補考成績`
- 這兩個欄位都會被查詢出來並存入 DataRow。
- 在分項成績計算時，會根據 takeScoreFields 或其他邏輯，靈活選擇要採計哪一個欄位。
- 這樣設計可支援「只用原始成績」或「原始及補考成績擇優」等多種計算需求。

## Todo 6: 再次修習成績寫回 subjScoreRows 以納入分項成績計算
- 目標：讓分項成績計算時也能正確納入「再次修習成績」。
- 步驟：
  1. 在處理每位學生時，針對 retakeDict[sid] 的每一筆 retake 成績：
     - 於 subjScoreRows（即 SemsSubjDataDict[sid]）中，找到對應的 DataRow（比對科目、學期、科目級別、年級）。
     - 將 retake.RetakeScore 覆蓋寫入 DataRow["原始成績"] 與 DataRow["補考成績"] 欄位。
  2. 這樣後續呼叫 CalcSemesterEntryScore 計算分項成績時，會自動採用「再次修習成績」作為該科目分數。
- 設計重點：
  - 覆蓋時需精確比對科目、學期、科目級別、年級，避免誤蓋其他成績。
  - 建議將覆蓋邏輯封裝為獨立方法，便於維護與測試。
  - 這樣可確保所有分項成績計算都能正確反映學生的最新修習成績。

---

### 補充：Utility.cs 內部呼叫 ScoreCalcHelper.CalcSemesterEntryScore 補上 chkSScore 參數
- 為配合新版方法簽名，Utility.cs 內部所有呼叫 ScoreCalcHelper.CalcSemesterEntryScore 的地方，已補上 chkSScore 參數。
- 預設傳 true（僅採計原始成績），或可依需求傳遞。
- 範例：
  ```csharp
  var entryScores = ScoreCalcHelper.CalcSemesterEntryScore(subjRows, sid, g, s, getScoreCalcRule, true);
  ```
- 這樣可確保所有呼叫點都不會出現缺少參數的錯誤，並可彈性控制分項成績計算方式。

## Todo 7: ScoreForm103_1.cs 比照 ScoreForm111.cs 實作再次修習與即時計算學期分項
- 需將 ScoreForm103_1.cs 依照 ScoreForm111.cs 的邏輯進行調整，包含：
  1. 實作「再次修習成績」覆蓋：取得 retakeScores，將 retake.RetakeScore 覆蓋 newRow 及 subjScoreRows（SemsSubjDataDict[sid]）的原始成績、補考成績。
  2. 整理需重新計算的 (gradeYear, semester) 組合，呼叫 ScoreCalcHelper.CalcSemesterEntryScore 進行即時計算，並補上 _chkSScore 參數。
  3. 將即時計算結果覆蓋 newRow 對應分項欄位。
- 這樣可確保 ScoreForm103_1.cs 與 ScoreForm111.cs 行為一致，支援再次修習成績與分項成績即時計算。
- 修改後需測試所有匯出、計算流程，確保功能正確。

## Todo 8: ScoreForm.cs 比照 ScoreForm111.cs 實作再次修習與即時計算學期分項
- 需將 ScoreForm.cs 依照 ScoreForm111.cs 的邏輯進行調整，包含：
  1. 實作「再次修習成績」覆蓋：取得 retakeScores，將 retake.RetakeScore 覆蓋 newRow 及 subjScoreRows（SemsSubjDataDict[sid]）的原始成績、補考成績。
  2. 整理需重新計算的 (gradeYear, semester) 組合，呼叫 ScoreCalcHelper.CalcSemesterEntryScore 進行即時計算，並補上 _chkSScore 參數。
  3. 將即時計算結果覆蓋 newRow 對應分項欄位。
- 這樣可確保 ScoreForm.cs 與 ScoreForm111.cs 行為一致，支援再次修習成績與分項成績即時計算。
- 修改後需測試所有匯出、計算流程，確保功能正確。

  