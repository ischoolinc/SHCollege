# 大學繁星調整 0814

## Todo 1: 在 CalcSemesterEntryScore 方法中取得科目名稱

### 目標
在 `Utility.cs` 的 `CalcSemesterEntryScore` 方法中，除了現有的分項類別、學分數、成績等資訊外，還需要取得科目名稱。

### 現況分析
目前 `CalcSemesterEntryScore` 方法中的 `subjScoreRows` 資料來源包含以下欄位：
- `分項類別`：用於分類（如學業、體育等）
- `學分數`：該科目的學分數
- `原始成績`、`補考成績`：用於計算最高成績
- `成績年級`、`學期`：用於篩選特定年級學期

### 取得科目名稱的方法

#### 方法 1：直接從 DataRow 取得
```csharp
// 在現有的 foreach 迴圈中，加入科目名稱取得
foreach (var dr in subjScoreRows)
{
    if (dr["成績年級"].ToString() == gradeYear.ToString() && dr["學期"].ToString() == semester.ToString())
    {
        // ... 現有的篩選邏輯 ...
        
        string entry = dr["分項類別"].ToString();
        if (entry == "學業")
            entry = "學業成績總平均";
            
        // 新增：取得科目名稱
        string subjectName = "";
        if (dr.Table.Columns.Contains("科目"))
            subjectName = dr["科目"].ToString();
        else if (dr.Table.Columns.Contains("subject"))
            subjectName = dr["subject"].ToString();
            
        decimal credit = 0, maxScore = 0, tryScore = 0;
        decimal.TryParse(dr["學分數"].ToString(), out credit);
        
        // ... 現有的成績計算邏輯 ...
    }
}
```

#### 方法 2：建立科目名稱對應字典
```csharp
// 在方法開始處建立科目名稱對應
var subjectNameMapping = new Dictionary<string, string>();

foreach (var dr in subjScoreRows)
{
    if (dr["成績年級"].ToString() == gradeYear.ToString() && dr["學期"].ToString() == semester.ToString())
    {
        // ... 現有的篩選邏輯 ...
        
        string entry = dr["分項類別"].ToString();
        if (entry == "學業")
            entry = "學業成績總平均";
            
        // 新增：取得科目名稱並建立對應
        string subjectName = "";
        if (dr.Table.Columns.Contains("科目"))
            subjectName = dr["科目"].ToString();
        else if (dr.Table.Columns.Contains("subject"))
            subjectName = dr["subject"].ToString();
            
        // 建立分項類別與科目名稱的對應
        if (!subjectNameMapping.ContainsKey(entry))
            subjectNameMapping[entry] = "";
        if (!string.IsNullOrEmpty(subjectName))
            subjectNameMapping[entry] += (string.IsNullOrEmpty(subjectNameMapping[entry]) ? "" : ", ") + subjectName;
            
        // ... 現有的成績計算邏輯 ...
    }
}
```

#### 方法 3：擴展現有的結果結構
```csharp
// 修改回傳值結構，包含科目名稱資訊
public static Dictionary<string, (decimal score, string subjects)> CalcSemesterEntryScore(
    List<DataRow> subjScoreRows,
    string studentID,
    int gradeYear,
    int semester,
    Func<string, System.Xml.XmlElement> getScoreCalcRule,
    bool chkSScore)
{
    // ... 現有的邏輯 ...
    
    var entryCreditCount = new Dictionary<string, decimal>();
    var entryDividend = new Dictionary<string, decimal>();
    var entrySubjects = new Dictionary<string, HashSet<string>>(); // 新增：記錄科目名稱
    
    foreach (var dr in subjScoreRows)
    {
        // ... 現有的篩選邏輯 ...
        
        string entry = dr["分項類別"].ToString();
        if (entry == "學業")
            entry = "學業成績總平均";
            
        // 新增：取得科目名稱
        string subjectName = "";
        if (dr.Table.Columns.Contains("科目"))
            subjectName = dr["科目"].ToString();
        else if (dr.Table.Columns.Contains("subject"))
            subjectName = dr["subject"].ToString();
            
        // 記錄科目名稱
        if (!entrySubjects.ContainsKey(entry))
            entrySubjects[entry] = new HashSet<string>();
        if (!string.IsNullOrEmpty(subjectName))
            entrySubjects[entry].Add(subjectName);
            
        // ... 現有的成績計算邏輯 ...
    }
    
    // 修改回傳值，包含科目名稱
    var result = new Dictionary<string, (decimal score, string subjects)>();
    foreach (var entry in entryCreditCount.Keys)
    {
        if (entryCreditCount[entry] > 0)
        {
            decimal avg = entryDividend[entry] / entryCreditCount[entry];
            // ... 現有的四捨五入邏輯 ...
            
            string subjects = string.Join(", ", entrySubjects[entry]);
            result[entry] = (rounded, subjects);
        }
    }
    return result;
}
```

### 建議實作方式
推薦使用**方法 1**，因為：
1. 對現有程式碼影響最小
2. 不需要大幅修改方法簽名
3. 可以透過額外的參數或回傳值來傳遞科目名稱資訊
4. 保持向後相容性

### 方法1詳細實作步驟

#### 步驟1：在方法中新增科目名稱變數
```csharp
// 在現有的 entryCreditCount 和 entryDividend 字典後，新增科目名稱記錄
var entryCreditCount = new Dictionary<string, decimal>();
var entryDividend = new Dictionary<string, decimal>();
var entrySubjects = new Dictionary<string, List<string>>(); // 新增：記錄每個分項包含的科目
```

#### 步驟2：在 foreach 迴圈中取得科目名稱
```csharp
foreach (var dr in subjScoreRows)
{
    if (dr["成績年級"].ToString() == gradeYear.ToString() && dr["學期"].ToString() == semester.ToString())
    {
        // ... 現有的篩選邏輯 ...
        
        string entry = dr["分項類別"].ToString();
        if (entry == "學業")
            entry = "學業成績總平均";
            
        // 新增：取得科目名稱
        string subjectName = "";
        if (dr.Table.Columns.Contains("科目"))
            subjectName = dr["科目"].ToString();
        else if (dr.Table.Columns.Contains("subject"))
            subjectName = dr["subject"].ToString();
            
        // 新增：記錄科目名稱到對應的分項
        if (!entrySubjects.ContainsKey(entry))
            entrySubjects[entry] = new List<string>();
        if (!string.IsNullOrEmpty(subjectName) && !entrySubjects[entry].Contains(subjectName))
            entrySubjects[entry].Add(subjectName);
            
        // ... 現有的成績計算邏輯 ...
    }
}
```

#### 步驟3：建立科目名稱字串（可選）
```csharp
// 在計算完分項成績後，可以建立科目名稱字串供後續使用
var subjectNameStrings = new Dictionary<string, string>();
foreach (var entry in entrySubjects.Keys)
{
    if (entrySubjects[entry].Count > 0)
    {
        subjectNameStrings[entry] = string.Join(", ", entrySubjects[entry]);
    }
    else
    {
        subjectNameStrings[entry] = "";
    }
}
```

#### 步驟4：回傳科目名稱資訊（可選）
```csharp
// 方法最後可以選擇性地回傳科目名稱資訊
// 方式1：透過 out 參數
public static Dictionary<string, decimal> CalcSemesterEntryScore(
    List<DataRow> subjScoreRows,
    string studentID,
    int gradeYear,
    int semester,
    Func<string, System.Xml.XmlElement> getScoreCalcRule,
    bool chkSScore,
    out Dictionary<string, string> subjectNames) // 新增 out 參數
    
// 方式2：透過額外的回傳值（需要修改呼叫端）
public static (Dictionary<string, decimal> scores, Dictionary<string, string> subjects) 
    CalcSemesterEntryScore(...)
```

### 實作範例：完整的方法1實作
```csharp
public static Dictionary<string, decimal> CalcSemesterEntryScore(
    List<DataRow> subjScoreRows,
    string studentID,
    int gradeYear,
    int semester,
    Func<string, System.Xml.XmlElement> getScoreCalcRule,
    bool chkSScore)
{
    // ... 現有的規則解析邏輯 ...
    
    var entryCreditCount = new Dictionary<string, decimal>();
    var entryDividend = new Dictionary<string, decimal>();
    var entrySubjects = new Dictionary<string, List<string>>(); // 新增：記錄科目名稱
    
    foreach (var dr in subjScoreRows)
    {
        if (dr["成績年級"].ToString() == gradeYear.ToString() && dr["學期"].ToString() == semester.ToString())
        {
            if (dr.Table.Columns.Contains("不需評分") && dr["不需評分"].ToString() == "是")
                continue;
            if (dr.Table.Columns.Contains("不計學分") && dr["不計學分"].ToString() == "是")
                continue;
            if (dr.Table.Columns.Contains("補修成績") && dr["補修成績"].ToString() == "是")
                continue;

            string entry = dr["分項類別"].ToString();
            if (entry == "學業")
                entry = "學業成績總平均";
                
            // 新增：取得科目名稱
            string subjectName = "";
            if (dr.Table.Columns.Contains("科目"))
                subjectName = dr["科目"].ToString();
            else if (dr.Table.Columns.Contains("subject"))
                subjectName = dr["subject"].ToString();
                
            // 新增：記錄科目名稱
            if (!entrySubjects.ContainsKey(entry))
                entrySubjects[entry] = new List<string>();
            if (!string.IsNullOrEmpty(subjectName) && !entrySubjects[entry].Contains(subjectName))
                entrySubjects[entry].Add(subjectName);
                
            decimal credit = 0, maxScore = 0, tryScore = 0;
            decimal.TryParse(dr["學分數"].ToString(), out credit);

            foreach (var field in takeScoreFields)
            {
                if (dr.Table.Columns.Contains(field) && decimal.TryParse(dr[field].ToString(), out tryScore))
                    if (tryScore > maxScore) maxScore = tryScore;
            }

            if (!entryCreditCount.ContainsKey(entry))
                entryCreditCount[entry] = 0;
            if (!entryDividend.ContainsKey(entry))
                entryDividend[entry] = 0;

            entryCreditCount[entry] += credit;
            entryDividend[entry] += maxScore * credit;
        }
    }

    // 計算分項成績（現有邏輯）
    var result = new Dictionary<string, decimal>();
    foreach (var entry in entryCreditCount.Keys)
    {
        if (entryCreditCount[entry] > 0)
        {
            decimal avg = entryDividend[entry] / entryCreditCount[entry];
            decimal pow = (decimal)Math.Pow(10, decimals);
            decimal rounded;
            if (mode == RoundMode.無條件捨去)
                rounded = Math.Floor(avg * pow) / pow;
            else if (mode == RoundMode.無條件進位)
                rounded = Math.Ceiling(avg * pow) / pow;
            else // 四捨五入
                rounded = Math.Round(avg, decimals, MidpointRounding.AwayFromZero);
            result[entry] = rounded;
        }
    }
    
    // 新增：可以選擇性地記錄科目名稱資訊供後續使用
    // 這裡可以透過全域變數、靜態變數或其他方式傳遞科目名稱資訊
    
    return result;
}
```

### 後續使用科目名稱的方式

#### 方式1：透過全域變數
```csharp
// 在類別層級定義靜態變數
private static Dictionary<string, List<string>> _lastEntrySubjects;

// 在 CalcSemesterEntryScore 方法最後設定
_lastEntrySubjects = entrySubjects;

// 其他方法可以透過 _lastEntrySubjects 取得科目名稱
```

#### 方式2：透過呼叫端傳入的委派
```csharp
// 修改方法簽名，增加科目名稱回傳的委派
public static Dictionary<string, decimal> CalcSemesterEntryScore(
    List<DataRow> subjScoreRows,
    string studentID,
    int gradeYear,
    int semester,
    Func<string, System.Xml.XmlElement> getScoreCalcRule,
    bool chkSScore,
    Action<Dictionary<string, List<string>>> onSubjectsCollected = null) // 新增回調
    
// 在方法最後呼叫委派
onSubjectsCollected?.Invoke(entrySubjects);
```

### 注意事項
1. 需要檢查 `subjScoreRows` 中是否包含 `科目` 或 `subject` 欄位
2. 科目名稱可能為空值，需要適當的 null 檢查
3. 如果同一個分項類別包含多個科目，需要決定如何處理（如用逗號分隔、只取第一個等）
4. 修改後需要測試所有呼叫 `CalcSemesterEntryScore` 的地方，確保不會造成編譯錯誤
5. 科目名稱的傳遞方式需要根據實際使用需求來決定
6. 建議先實作基本的科目名稱取得功能，再根據後續需求調整傳遞方式

## Todo 2: 新增 Debug 資訊存到 debug.txt 檔案

### 目標
在 `CalcSemesterEntryScore` 方法中新增 debug 資訊，將以下4項關鍵值存到 `debug.txt` 檔案中：
1. 科目名稱
2. maxScore（最高成績）
3. credit（學分數）
4. maxScore * credit（加權分數）

### Debug 實作方式

#### 方式1：使用 File.AppendAllText（推薦用於開發階段）
```csharp
using System.IO;

// 在取得科目名稱後，加入 debug 記錄
string subjectName = "";
if (dr.Table.Columns.Contains("科目"))
    subjectName = dr["科目"].ToString();
else if (dr.Table.Columns.Contains("subject"))
    subjectName = dr["subject"].ToString();

// 新增：Debug 記錄科目名稱到檔案
File.AppendAllText("debug.txt", $"[DEBUG] 科目名稱: {subjectName}\n");

// ... 現有的成績計算邏輯 ...

// 在計算完 maxScore 後，加入 debug 記錄
foreach (var field in takeScoreFields)
{
    if (dr.Table.Columns.Contains(field) && decimal.TryParse(dr[field].ToString(), out tryScore))
        if (tryScore > maxScore) maxScore = tryScore;
}

// 新增：Debug 記錄最高成績到檔案
File.AppendAllText("debug.txt", $"[DEBUG] 最高成績 (maxScore): {maxScore}\n");

// 新增：Debug 記錄學分數到檔案
File.AppendAllText("debug.txt", $"[DEBUG] 學分數 (credit): {credit}\n");

// 新增：Debug 記錄加權分數到檔案
File.AppendAllText("debug.txt", $"[DEBUG] 加權分數 (maxScore * credit): {maxScore * credit}\n");

// 新增：Debug 記錄完整資訊到檔案（一行顯示）
File.AppendAllText("debug.txt", $"[DEBUG] 科目:{subjectName} | 最高成績:{maxScore} | 學分數:{credit} | 加權分數:{maxScore * credit}\n");
```

#### 方式2：使用 StreamWriter（推薦用於大量資料）
```csharp
using System.IO;

// 在方法開始處建立 StreamWriter
using (StreamWriter writer = new StreamWriter("debug.txt", true)) // true 表示 append 模式
{
    // 在取得科目名稱後，加入 debug 記錄
    string subjectName = "";
    if (dr.Table.Columns.Contains("科目"))
        subjectName = dr["科目"].ToString();
    else if (dr.Table.Columns.Contains("subject"))
        subjectName = dr["subject"].ToString();

    // 新增：Debug 記錄科目名稱到檔案
    writer.WriteLine($"[DEBUG] 科目名稱: {subjectName}");

    // ... 現有的成績計算邏輯 ...

    // 在計算完 maxScore 後，加入 debug 記錄
    foreach (var field in takeScoreFields)
    {
        if (dr.Table.Columns.Contains(field) && decimal.TryParse(dr[field].ToString(), out tryScore))
            if (tryScore > maxScore) maxScore = tryScore;
    }

    // 新增：Debug 記錄最高成績到檔案
    writer.WriteLine($"[DEBUG] 最高成績 (maxScore): {maxScore}");

    // 新增：Debug 記錄學分數到檔案
    writer.WriteLine($"[DEBUG] 學分數 (credit): {credit}");

    // 新增：Debug 記錄加權分數到檔案
    writer.WriteLine($"[DEBUG] 加權分數 (maxScore * credit): {maxScore * credit}");

    // 新增：Debug 記錄完整資訊到檔案（一行顯示）
    writer.WriteLine($"[DEBUG] 科目:{subjectName} | 最高成績:{maxScore} | 學分數:{credit} | 加權分數:{maxScore * credit}");
}
```

#### 方式3：使用自訂的 Debug 方法（推薦用於專案統一管理）
```csharp
using System.IO;

// 在類別中定義自訂的 Debug 方法
private static void DebugLogToFile(string message)
{
    #if DEBUG
    try
    {
        File.AppendAllText("debug.txt", $"[DEBUG] {DateTime.Now:HH:mm:ss.fff} - {message}\n");
    }
    catch (Exception ex)
    {
        // 如果寫入檔案失敗，可以選擇印出到控制台或忽略
        Console.WriteLine($"[ERROR] 無法寫入 debug.txt: {ex.Message}");
    }
    #endif
}

// 在 foreach 迴圈中使用
string subjectName = "";
if (dr.Table.Columns.Contains("科目"))
    subjectName = dr["科目"].ToString();
else if (dr.Table.Columns.Contains("subject"))
    subjectName = dr["subject"].ToString();

// 新增：Debug 記錄科目名稱到檔案
DebugLogToFile($"科目名稱: {subjectName}");

// ... 現有的成績計算邏輯 ...

// 在計算完 maxScore 後，加入 debug 記錄
foreach (var field in takeScoreFields)
{
    if (dr.Table.Columns.Contains(field) && decimal.TryParse(dr[field].ToString(), out tryScore))
        if (tryScore > maxScore) maxScore = tryScore;
}

// 新增：Debug 記錄最高成績到檔案
DebugLogToFile($"最高成績 (maxScore): {maxScore}");

// 新增：Debug 記錄學分數到檔案
DebugLogToFile($"學分數 (credit): {credit}");

// 新增：Debug 記錄加權分數到檔案
DebugLogToFile($"加權分數 (maxScore * credit): {maxScore * credit}");

// 新增：Debug 記錄完整資訊到檔案（一行顯示）
DebugLogToFile($"科目:{subjectName} | 最高成績:{maxScore} | 學分數:{credit} | 加權分數:{maxScore * credit}");
```

### 完整的 Debug 實作範例
```csharp
using System.IO;

foreach (var dr in subjScoreRows)
{
    if (dr["成績年級"].ToString() == gradeYear.ToString() && dr["學期"].ToString() == semester.ToString())
    {
        // ... 現有的篩選邏輯 ...
        
        string entry = dr["分項類別"].ToString();
        if (entry == "學業")
            entry = "學業成績總平均";
            
        // 新增：取得科目名稱
        string subjectName = "";
        if (dr.Table.Columns.Contains("科目"))
            subjectName = dr["科目"].ToString();
        else if (dr.Table.Columns.Contains("subject"))
            subjectName = dr["subject"].ToString();
            
        // 新增：Debug 記錄科目名稱到檔案
        File.AppendAllText("debug.txt", $"[DEBUG] 科目名稱: {subjectName}\n");
            
        decimal credit = 0, maxScore = 0, tryScore = 0;
        decimal.TryParse(dr["學分數"].ToString(), out credit);

        foreach (var field in takeScoreFields)
        {
            if (dr.Table.Columns.Contains(field) && decimal.TryParse(dr[field].ToString(), out tryScore))
                if (tryScore > maxScore) maxScore = tryScore;
        }

        // 新增：Debug 記錄最高成績到檔案
        File.AppendAllText("debug.txt", $"[DEBUG] 最高成績 (maxScore): {maxScore}\n");
        
        // 新增：Debug 記錄學分數到檔案
        File.AppendAllText("debug.txt", $"[DEBUG] 學分數 (credit): {credit}\n");
        
        // 新增：Debug 記錄加權分數到檔案
        File.AppendAllText("debug.txt", $"[DEBUG] 加權分數 (maxScore * credit): {maxScore * credit}\n");
        
        // 新增：Debug 記錄完整資訊到檔案（一行顯示）
        File.AppendAllText("debug.txt", $"[DEBUG] 科目:{subjectName} | 最高成績:{maxScore} | 學分數:{credit} | 加權分數:{maxScore * credit}\n");

        // ... 現有的成績計算邏輯 ...
    }
}
```

### Debug 檔案內容範例
```
[DEBUG] 科目名稱: 國語文
[DEBUG] 最高成績 (maxScore): 85
[DEBUG] 學分數 (credit): 4
[DEBUG] 加權分數 (maxScore * credit): 340
[DEBUG] 科目:國語文 | 最高成績:85 | 學分數:4 | 加權分數:340

[DEBUG] 科目名稱: 英語文
[DEBUG] 最高成績 (maxScore): 92
[DEBUG] 學分數 (credit): 4
[DEBUG] 加權分數 (maxScore * credit): 368
[DEBUG] 科目:英語文 | 最高成績:92 | 學分數:4 | 加權分數:368
```

### 建議實作方式
推薦使用**方式1（File.AppendAllText）**，因為：
1. 簡單直接，容易實作
2. 自動處理檔案開啟和關閉
3. 不需要額外的 using 區塊管理
4. 可以快速驗證計算邏輯是否正確

### 方式1詳細實作步驟

#### 步驟1：在方法開始處加入 using 引用
```csharp
using System.IO;
```

#### 步驟2：在方法開始時清空 debug.txt 檔案
```csharp
// 在方法開始處，清空 debug.txt 檔案避免累積過多資料
try
{
    if (File.Exists("debug.txt"))
        File.Delete("debug.txt");
}
catch (Exception ex)
{
    // 如果無法刪除檔案，可以選擇忽略或記錄錯誤
    Console.WriteLine($"[WARNING] 無法清空 debug.txt: {ex.Message}");
}
```

#### 步驟3：在 foreach 迴圈中記錄科目名稱
```csharp
foreach (var dr in subjScoreRows)
{
    if (dr["成績年級"].ToString() == gradeYear.ToString() && dr["學期"].ToString() == semester.ToString())
    {
        // ... 現有的篩選邏輯 ...
        
        string entry = dr["分項類別"].ToString();
        if (entry == "學業")
            entry = "學業成績總平均";
            
        // 新增：取得科目名稱
        string subjectName = "";
        if (dr.Table.Columns.Contains("科目"))
            subjectName = dr["科目"].ToString();
        else if (dr.Table.Columns.Contains("subject"))
            subjectName = dr["subject"].ToString();
            
        // 新增：Debug 記錄科目名稱到檔案
        try
        {
            File.AppendAllText("debug.txt", $"[DEBUG] 科目名稱: {subjectName}\n");
        }
        catch (Exception ex)
        {
            // 如果寫入檔案失敗，可以選擇印出到控制台或忽略
            Console.WriteLine($"[ERROR] 無法寫入 debug.txt: {ex.Message}");
        }
            
        decimal credit = 0, maxScore = 0, tryScore = 0;
        decimal.TryParse(dr["學分數"].ToString(), out credit);

        foreach (var field in takeScoreFields)
        {
            if (dr.Table.Columns.Contains(field) && decimal.TryParse(dr[field].ToString(), out tryScore))
                if (tryScore > maxScore) maxScore = tryScore;
        }

        // 新增：Debug 記錄最高成績到檔案
        try
        {
            File.AppendAllText("debug.txt", $"[DEBUG] 最高成績 (maxScore): {maxScore}\n");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ERROR] 無法寫入 debug.txt: {ex.Message}");
        }
        
        // 新增：Debug 記錄學分數到檔案
        try
        {
            File.AppendAllText("debug.txt", $"[DEBUG] 學分數 (credit): {credit}\n");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ERROR] 無法寫入 debug.txt: {ex.Message}");
        }
        
        // 新增：Debug 記錄加權分數到檔案
        try
        {
            File.AppendAllText("debug.txt", $"[DEBUG] 加權分數 (maxScore * credit): {maxScore * credit}\n");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ERROR] 無法寫入 debug.txt: {ex.Message}");
        }
        
        // 新增：Debug 記錄完整資訊到檔案（一行顯示）
        try
        {
            File.AppendAllText("debug.txt", $"[DEBUG] 科目:{subjectName} | 最高成績:{maxScore} | 學分數:{credit} | 加權分數:{maxScore * credit}\n");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ERROR] 無法寫入 debug.txt: {ex.Message}");
        }

        // ... 現有的成績計算邏輯 ...
    }
}
```

#### 步驟4：在方法結束時記錄總結資訊
```csharp
// 在方法結束前，記錄分項成績計算結果
try
{
    File.AppendAllText("debug.txt", $"\n[DEBUG] ===== 分項成績計算結果 =====\n");
    foreach (var entry in result.Keys)
    {
        File.AppendAllText("debug.txt", $"[DEBUG] {entry}: {result[entry]}\n");
    }
    File.AppendAllText("debug.txt", $"[DEBUG] ===============================\n\n");
}
catch (Exception ex)
{
    Console.WriteLine($"[ERROR] 無法寫入 debug.txt: {ex.Message}");
}
```

### 完整的實作範例：整合方式1的 CalcSemesterEntryScore 方法
```csharp
public static Dictionary<string, decimal> CalcSemesterEntryScore(
    List<DataRow> subjScoreRows,
    string studentID,
    int gradeYear,
    int semester,
    Func<string, System.Xml.XmlElement> getScoreCalcRule,
    bool chkSScore)
{
    using System.IO;
    
    // 步驟1：清空 debug.txt 檔案
    try
    {
        if (File.Exists("debug.txt"))
            File.Delete("debug.txt");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[WARNING] 無法清空 debug.txt: {ex.Message}");
    }
    
    // 記錄方法開始資訊
    try
    {
        File.AppendAllText("debug.txt", $"[DEBUG] ===== CalcSemesterEntryScore 開始 =====\n");
        File.AppendAllText("debug.txt", $"[DEBUG] 學生ID: {studentID}, 年級: {gradeYear}, 學期: {semester}\n");
        File.AppendAllText("debug.txt", $"[DEBUG] 使用成績類型: {(chkSScore ? "原始成績" : "原始及補考成績擇優")}\n\n");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[ERROR] 無法寫入 debug.txt: {ex.Message}");
    }
    
    // ... 現有的規則解析邏輯 ...
    
    var entryCreditCount = new Dictionary<string, decimal>();
    var entryDividend = new Dictionary<string, decimal>();
    
    foreach (var dr in subjScoreRows)
    {
        if (dr["成績年級"].ToString() == gradeYear.ToString() && dr["學期"].ToString() == semester.ToString())
        {
            if (dr.Table.Columns.Contains("不需評分") && dr["不需評分"].ToString() == "是")
                continue;
            if (dr.Table.Columns.Contains("不計學分") && dr["不計學分"].ToString() == "是")
                continue;
            if (dr.Table.Columns.Contains("補修成績") && dr["補修成績"].ToString() == "是")
                continue;

            string entry = dr["分項類別"].ToString();
            if (entry == "學業")
                entry = "學業成績總平均";
                
            // 新增：取得科目名稱
            string subjectName = "";
            if (dr.Table.Columns.Contains("科目"))
                subjectName = dr["科目"].ToString();
            else if (dr.Table.Columns.Contains("subject"))
                subjectName = dr["subject"].ToString();
                
            // 新增：Debug 記錄科目名稱到檔案
            try
            {
                File.AppendAllText("debug.txt", $"[DEBUG] 科目名稱: {subjectName}\n");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] 無法寫入 debug.txt: {ex.Message}");
            }
                
            decimal credit = 0, maxScore = 0, tryScore = 0;
            decimal.TryParse(dr["學分數"].ToString(), out credit);

            foreach (var field in takeScoreFields)
            {
                if (dr.Table.Columns.Contains(field) && decimal.TryParse(dr[field].ToString(), out tryScore))
                    if (tryScore > maxScore) maxScore = tryScore;
            }

            // 新增：Debug 記錄所有計算值到檔案
            try
            {
                File.AppendAllText("debug.txt", $"[DEBUG] 最高成績 (maxScore): {maxScore}\n");
                File.AppendAllText("debug.txt", $"[DEBUG] 學分數 (credit): {credit}\n");
                File.AppendAllText("debug.txt", $"[DEBUG] 加權分數 (maxScore * credit): {maxScore * credit}\n");
                File.AppendAllText("debug.txt", $"[DEBUG] 科目:{subjectName} | 最高成績:{maxScore} | 學分數:{credit} | 加權分數:{maxScore * credit}\n\n");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] 無法寫入 debug.txt: {ex.Message}");
            }

            if (!entryCreditCount.ContainsKey(entry))
                entryCreditCount[entry] = 0;
            if (!entryDividend.ContainsKey(entry))
                entryDividend[entry] = 0;

            entryCreditCount[entry] += credit;
            entryDividend[entry] += maxScore * credit;
        }
    }

    // 計算分項成績（現有邏輯）
    var result = new Dictionary<string, decimal>();
    foreach (var entry in entryCreditCount.Keys)
    {
        if (entryCreditCount[entry] > 0)
        {
            decimal avg = entryDividend[entry] / entryCreditCount[entry];
            decimal pow = (decimal)Math.Pow(10, decimals);
            decimal rounded;
            if (mode == RoundMode.無條件捨去)
                rounded = Math.Floor(avg * pow) / pow;
            else if (mode == RoundMode.無條件進位)
                rounded = Math.Ceiling(avg * pow) / pow;
            else // 四捨五入
                rounded = Math.Round(avg, decimals, MidpointRounding.AwayFromZero);
            result[entry] = rounded;
        }
    }
    
    // 步驟4：記錄分項成績計算結果
    try
    {
        File.AppendAllText("debug.txt", $"[DEBUG] ===== 分項成績計算結果 =====\n");
        foreach (var entry in result.Keys)
        {
            File.AppendAllText("debug.txt", $"[DEBUG] {entry}: {result[entry]}\n");
        }
        File.AppendAllText("debug.txt", $"[DEBUG] ===============================\n");
        File.AppendAllText("debug.txt", $"[DEBUG] ===== CalcSemesterEntryScore 結束 =====\n\n");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[ERROR] 無法寫入 debug.txt: {ex.Message}");
    }
    
    return result;
}
```

### 預期的 debug.txt 檔案內容
```
[DEBUG] ===== CalcSemesterEntryScore 開始 =====
[DEBUG] 學生ID: S001, 年級: 2, 學期: 1
[DEBUG] 使用成績類型: 原始及補考成績擇優

[DEBUG] 科目名稱: 國語文
[DEBUG] 最高成績 (maxScore): 85
[DEBUG] 學分數 (credit): 4
[DEBUG] 加權分數 (maxScore * credit): 340
[DEBUG] 科目:國語文 | 最高成績:85 | 學分數:4 | 加權分數:340

[DEBUG] 科目名稱: 英語文
[DEBUG] 最高成績 (maxScore): 92
[DEBUG] 學分數 (credit): 4
[DEBUG] 加權分數 (maxScore * credit): 368
[DEBUG] 科目:英語文 | 最高成績:92 | 學分數:4 | 加權分數:368

[DEBUG] ===== 分項成績計算結果 =====
[DEBUG] 學業成績總平均: 88.5
[DEBUG] ===============================
[DEBUG] ===== CalcSemesterEntryScore 結束 =====
```

### 注意事項
1. Debug 資訊僅用於開發階段，正式環境建議移除或使用條件編譯
2. 輸出格式要統一，便於後續分析
3. 可以考慮加入時間戳記，追蹤執行順序
4. 建議先實作基本的 debug 輸出，再根據需求調整格式
5. 如果資料量很大，可以考慮只輸出特定條件下的 debug 資訊
6. 檔案路徑建議使用相對路徑或可設定的路徑
7. 需要處理檔案寫入權限和磁碟空間不足的異常情況
8. 建議在方法開始時清空 debug.txt 檔案，避免累積過多資料
9. 每個 File.AppendAllText 呼叫都應該包在 try-catch 區塊中
10. 可以考慮將 debug 功能包裝成可開關的設定，方便控制是否啟用

### 如何停用 Debug 功能

如果您不想要產生 `debug.txt` 檔案，可以註解掉所有與 debug 寫入相關的程式碼行。

#### 需要註解的寫入行數（共 12 行）：

**1. 方法開始處的寫入（3 行）：**
```csharp
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] ===== CalcSemesterEntryScore 開始 =====\n");
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] 學生ID: {studentID}, 年級: {gradeYear}, 學期: {semester}\n");
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] 使用成績類型: {(chkSScore ? "原始成績" : "原始及補考成績擇優")}\n\n");
```

**2. foreach 迴圈中的科目名稱寫入（1 行）：**
```csharp
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] 科目名稱: {subjectName}\n");
```

**3. foreach 迴圈中的計算值寫入（4 行）：**
```csharp
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] 最高成績 (maxScore): {maxScore}\n");
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] 學分數 (credit): {credit}\n");
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] 加權分數 (maxScore * credit): {maxScore * credit}\n");
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] 科目:{subjectName} | 最高成績:{maxScore} | 學分數:{credit} | 加權分數:{maxScore * credit}\n\n");
```

**4. 方法結束處的分項成績計算結果寫入（4 行）：**
```csharp
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] ===== 分項成績計算結果 =====\n");
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] {entry}: {result[entry]}\n");
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] ===============================\n");
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] ===== CalcSemesterEntryScore 結束 =====\n\n");
```

#### 註解方式：
在每行前面加上 `//` 即可停用該行的 debug 寫入功能。

#### 停用後的影響：
- 不會產生 `debug.txt` 檔案
- 科目名稱的取得功能（Todo 1）仍然正常運作
- 科目名稱仍然會被記錄在 `entryDividend` 字典中
- 程式執行效能會稍微提升（減少檔案 I/O 操作）

#### 建議：
- 開發階段：保留 debug 功能，方便除錯和驗證計算邏輯
- 正式環境：註解掉 debug 功能，提升執行效能
- 可以考慮使用條件編譯（`#if DEBUG`）來控制 debug 功能的啟用

### 實作結果：Debug 功能已註解

#### 註解完成狀態
✅ **已完成**：所有與 `debug.txt` 相關的程式碼行都已被註解

#### 註解內容總結
**已註解的 debug 功能（共 12 行）：**

1. **方法開始處的寫入（3 行）：**
   - 清空 debug.txt 檔案
   - 記錄方法開始資訊
   - 記錄學生ID、年級、學期、成績類型

2. **foreach 迴圈中的科目名稱寫入（1 行）：**
   - 記錄科目名稱

3. **foreach 迴圈中的計算值寫入（4 行）：**
   - 記錄最高成績 (maxScore)
   - 記錄學分數 (credit)
   - 記錄加權分數 (maxScore * credit)
   - 記錄完整資訊一行顯示

4. **方法結束處的分項成績計算結果寫入（4 行）：**
   - 記錄分項成績計算結果標題
   - 記錄每個分項的成績
   - 記錄分隔線
   - 記錄方法結束標記

#### 註解後的影響
- ✅ 不會產生 `debug.txt` 檔案
- ✅ 科目名稱的取得功能（Todo 1）仍然正常運作
- ✅ 科目名稱仍然會被記錄在 `entrySubjects` 字典中
- ✅ 程式執行效能會稍微提升（減少檔案 I/O 操作）
- ✅ 所有 debug 功能都被保留，只是暫時停用

#### 如何重新啟用
如果將來需要重新啟用 debug 功能，只需要將所有註解掉的程式碼行前面的 `//` 移除即可。

#### 註解方式
使用 `//` 註解符號，將原本的程式碼行註解掉：
```csharp
// 原本的程式碼
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] 科目名稱: {subjectName}\n");

// 註解後的程式碼
// System.IO.File.AppendAllText("debug.txt", $"[DEBUG] 科目名稱: {subjectName}\n");
```

#### 當前狀態
現在 `Utility.cs` 中的 `CalcSemesterEntryScore` 方法：
- 科目名稱取得功能（Todo 1）正常運作
- Debug 功能（Todo 2）已完全註解
- 不會產生任何 debug.txt 檔案
- 程式執行效能提升

## Todo 3: 檢查並統一 GetEntryFieldName 方法實作

### 目標
檢查 `ScoreForm111.cs` 與 `ScoreForm103_1.cs` 中的 `GetEntryFieldName` 方法內容是否相同，如果不相同，以 `ScoreForm111.cs` 為主進行統一。

### 檢查結果

#### ScoreForm111.cs 中的 GetEntryFieldName 方法：
```csharp
// 工具方法：分項欄位命名（如學業成績總平均(高二下)）
private string GetEntryFieldName(string entry, int gradeYear, int semester)
{
    string[] gradeMap = { "", "高一", "高二", "高三", "高四", "高五", "高六" };
    string[] semMap = { "", "上", "下" };
    string postfix = "";
    if (gradeYear >= 1 && gradeYear <= 6 && semester >= 1 && semester <= 2)
        postfix = $"({gradeMap[gradeYear]}{semMap[semester]})";
    return entry + postfix;
}
```

#### ScoreForm103_1.cs 中的 GetEntryFieldName 方法：
```csharp
// 工具方法：取得分項欄位名稱
private string GetEntryFieldName(string fieldName, int gradeYear, int semester)
{
    string retVal = fieldName;
    if (fieldName.Contains("(高一上)"))
        retVal = fieldName.Replace("(高一上)", $"({GetGradeSemesterString(gradeYear, semester)})");
    else if (fieldName.Contains("(高一下)"))
        retVal = fieldName.Replace("(高一下)", $"({GetGradeSemesterString(gradeYear, semester)})");
    else if (fieldName.Contains("(高二上)"))
        retVal = fieldName.Replace("(高二上)", $"({GetGradeSemesterString(gradeYear, semester)})");
    else if (fieldName.Contains("(高二下)"))
        retVal = fieldName.Replace("(高二下)", $"({GetGradeSemesterString(gradeYear, semester)})");
    else if (fieldName.Contains("(高三上)"))
        retVal = fieldName.Replace("(高三上)", $"({GetGradeSemesterString(gradeYear, semester)})");
    else if (fieldName.Contains("(高三下)"))
        retVal = fieldName.Replace("(高三下)", $"({GetGradeSemesterString(gradeYear, semester)})");
    return retVal;
}
```

### 差異分析

#### 1. **方法簽名不同**：
- **ScoreForm111.cs**: `GetEntryFieldName(string entry, int gradeYear, int semester)`
- **ScoreForm103_1.cs**: `GetEntryFieldName(string fieldName, int gradeYear, int semester)`

#### 2. **實作邏輯完全不同**：
- **ScoreForm111.cs**: 使用陣列映射，直接根據年級和學期生成後綴，支援高一到高六
- **ScoreForm103_1.cs**: 使用字串替換，只支援高一到高三，需要先檢查欄位名稱中是否包含特定年級學期

#### 3. **支援的年級範圍**：
- **ScoreForm111.cs**: 支援高一到高六（gradeYear 1-6）
- **ScoreForm103_1.cs**: 只支援高一到高三（gradeYear 1-3）

#### 4. **邏輯複雜度**：
- **ScoreForm111.cs**: 邏輯簡單清晰，直接生成後綴
- **ScoreForm103_1.cs**: 邏輯複雜，需要多個 if-else 判斷

### 建議修改方案

以 `ScoreForm111.cs` 為主，將 `ScoreForm103_1.cs` 的 `GetEntryFieldName` 方法修改為：

```csharp
// 工具方法：分項欄位命名（如學業成績總平均(高二下)）
private string GetEntryFieldName(string entry, int gradeYear, int semester)
{
    string[] gradeMap = { "", "高一", "高二", "高三", "高四", "高五", "高六" };
    string[] semMap = { "", "上", "下" };
    string postfix = "";
    if (gradeYear >= 1 && gradeYear <= 6 && semester >= 1 && semester <= 2)
        postfix = $"({gradeMap[gradeYear]}{semMap[semester]})";
    return entry + postfix;
}
```

### 修改後的檢查

修改完成後，兩個檔案的 `GetEntryFieldName` 方法應該完全相同，包括：
1. 方法簽名一致
2. 實作邏輯一致
3. 支援的年級範圍一致（高一到高六）
4. 程式碼結構一致

### 注意事項

1. **參數名稱統一**：將 `fieldName` 改為 `entry` 以保持一致性
2. **移除舊的實作**：刪除複雜的 if-else 邏輯
3. **保持功能**：確保修改後的功能與原本一致
4. **測試驗證**：修改後需要測試確保功能正常運作

## Todo 4: 檢查並統一 ScoreForm.cs 的 GetEntryFieldName 方法實作

### 目標
檢查 `ScoreForm111.cs` 與 `ScoreForm.cs` 中的 `GetEntryFieldName` 方法內容是否相同，如果不相同，以 `ScoreForm111.cs` 為主進行統一。

### 檢查結果

#### ScoreForm111.cs 中的 GetEntryFieldName 方法：
```csharp
// 工具方法：分項欄位命名（如學業成績總平均(高二下)）
private string GetEntryFieldName(string entry, int gradeYear, int semester)
{
    string[] gradeMap = { "", "高一", "高二", "高三", "高四", "高五", "高六" };
    string[] semMap = { "", "上", "下" };
    string postfix = "";
    if (gradeYear >= 1 && gradeYear <= 6 && semester >= 1 && semester <= 2)
        postfix = $"({gradeMap[gradeYear]}{semMap[semester]})";
    return entry + postfix;
}
```

#### ScoreForm.cs 中的 GetEntryFieldName 方法：
```csharp
// 工具方法：取得分項欄位名稱
private string GetEntryFieldName(string fieldName, int gradeYear, int semester)
{
    string retVal = fieldName;
    if (fieldName.Contains("(高一上)"))
        retVal = fieldName.Replace("(高一上)", $"({GetGradeSemesterString(gradeYear, semester)})");
    else if (fieldName.Contains("(高一下)"))
        retVal = fieldName.Replace("(高一下)", $"({GetGradeSemesterString(gradeYear, semester)})");
    else if (fieldName.Contains("(高二上)"))
        retVal = fieldName.Replace("(高二上)", $"({GetGradeSemesterString(gradeYear, semester)})");
    else if (fieldName.Contains("(高二下)"))
        retVal = fieldName.Replace("(高二下)", $"({GetGradeSemesterString(gradeYear, semester)})");
    else if (fieldName.Contains("(高三上)"))
        retVal = fieldName.Replace("(高三上)", $"({GetGradeSemesterString(gradeYear, semester)})");
    else if (fieldName.Contains("(高三下)"))
        retVal = fieldName.Replace("(高三下)", $"({GetGradeSemesterString(gradeYear, semester)})");
    return retVal;
}
```

### 差異分析

#### 1. **方法簽名不同**：
- **ScoreForm111.cs**: `GetEntryFieldName(string entry, int gradeYear, int semester)`
- **ScoreForm.cs**: `GetEntryFieldName(string fieldName, int gradeYear, int semester)`

#### 2. **實作邏輯完全不同**：
- **ScoreForm111.cs**: 使用陣列映射，直接根據年級和學期生成後綴，支援高一到高六
- **ScoreForm.cs**: 使用字串替換，只支援高一到高三，需要先檢查欄位名稱中是否包含特定年級學期

#### 3. **支援的年級範圍**：
- **ScoreForm111.cs**: 支援高一到高六（gradeYear 1-6）
- **ScoreForm.cs**: 只支援高一到高三（gradeYear 1-3）

#### 4. **邏輯複雜度**：
- **ScoreForm111.cs**: 邏輯簡單清晰，直接生成後綴
- **ScoreForm.cs**: 邏輯複雜，需要多個 if-else 判斷

#### 5. **依賴方法**：
- **ScoreForm111.cs**: 不依賴其他方法
- **ScoreForm.cs**: 依賴 `GetGradeSemesterString` 方法

### 建議修改方案

以 `ScoreForm111.cs` 為主，將 `ScoreForm.cs` 的 `GetEntryFieldName` 方法修改為：

```csharp
// 工具方法：分項欄位命名（如學業成績總平均(高二下)）
private string GetEntryFieldName(string entry, int gradeYear, int semester)
{
    string[] gradeMap = { "", "高一", "高二", "高三", "高四", "高五", "高六" };
    string[] semMap = { "", "上", "下" };
    string postfix = "";
    if (gradeYear >= 1 && gradeYear <= 6 && semester >= 1 && semester <= 2)
        postfix = $"({gradeMap[gradeYear]}{semMap[semester]})";
    return entry + postfix;
}
```

### 修改後的檢查

修改完成後，兩個檔案的 `GetEntryFieldName` 方法應該完全相同，包括：
1. 方法簽名一致
2. 實作邏輯一致
3. 支援的年級範圍一致（高一到高六）
4. 程式碼結構一致

### 注意事項

1. **參數名稱統一**：將 `fieldName` 改為 `entry` 以保持一致性
2. **移除舊的實作**：刪除複雜的 if-else 邏輯
3. **移除依賴方法**：可以考慮移除不再使用的 `GetGradeSemesterString` 方法
4. **保持功能**：確保修改後的功能與原本一致
5. **測試驗證**：修改後需要測試確保功能正常運作

### 總結

目前發現三個檔案（`ScoreForm111.cs`、`ScoreForm103_1.cs`、`ScoreForm.cs`）的 `GetEntryFieldName` 方法實作都不相同，建議統一使用 `ScoreForm111.cs` 的實作方式，這樣可以：
- 保持程式碼一致性
- 支援更廣的年級範圍
- 簡化邏輯，提高可維護性
- 減少重複程式碼

